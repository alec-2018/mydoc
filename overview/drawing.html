<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drawing &mdash; LVGL  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/fontawesome.min.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="canonical" href="https://docs.lvgl.io/0.0.1/overview/drawing.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-78811084-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

	gtag('config', 'UA-78811084-3', { 'anonymize_ip': true });
</script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html">
            
              <img src="../_static/logo_lvgl.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Drawing</a><ul>
<li><a class="reference internal" href="#mechanism-of-screen-refreshing">Mechanism of screen refreshing</a></li>
<li><a class="reference internal" href="#masking">Masking</a><ul>
<li><a class="reference internal" href="#using-masks">Using masks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hook-drawing">Hook drawing</a><ul>
<li><a class="reference internal" href="#main-drawing">Main drawing</a><ul>
<li><a class="reference internal" href="#lv-event-draw-main-begin">LV_EVENT_DRAW_MAIN_BEGIN</a></li>
<li><a class="reference internal" href="#lv-event-draw-main">LV_EVENT_DRAW_MAIN</a></li>
<li><a class="reference internal" href="#lv-event-draw-main-end">LV_EVENT_DRAW_MAIN_END</a></li>
</ul>
</li>
<li><a class="reference internal" href="#post-drawing">Post drawing</a><ul>
<li><a class="reference internal" href="#lv-event-draw-post-begin">LV_EVENT_DRAW_POST_BEGIN</a></li>
<li><a class="reference internal" href="#lv-event-draw-post">LV_EVENT_DRAW_POST</a></li>
<li><a class="reference internal" href="#lv-event-draw-post-end">LV_EVENT_DRAW_POST_END</a></li>
</ul>
</li>
<li><a class="reference internal" href="#part-drawing">Part drawing</a><ul>
<li><a class="reference internal" href="#lv-event-draw-part-begin">LV_EVENT_DRAW_PART_BEGIN</a></li>
<li><a class="reference internal" href="#lv-event-draw-part-end">LV_EVENT_DRAW_PART_END</a></li>
</ul>
</li>
<li><a class="reference internal" href="#others">Others</a><ul>
<li><a class="reference internal" href="#lv-event-cover-check">LV_EVENT_COVER_CHECK</a></li>
<li><a class="reference internal" href="#lv-event-refr-ext-draw-size">LV_EVENT_REFR_EXT_DRAW_SIZE</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">LVGL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Drawing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/overview/drawing.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="highlight-eval_rst notranslate"><div class="highlight"><pre><span></span>.. include:: /header.rst 
:github_url: |github_link_base|/overview/drawing.md
</pre></div>
</div>
<section class="tex2jax_ignore mathjax_ignore" id="drawing">
<h1>Drawing<a class="headerlink" href="#drawing" title="此标题的永久链接"></a></h1>
<p>With LVGL, you don't need to draw anything manually. Just create objects (like buttons, labels, arc, etc.), move and change them, and LVGL will refresh and redraw what is required.</p>
<p>However, it can be useful to have a basic understanding of how drawing happens in LVGL to add customization, make it easier to find bugs or just out of curiosity.</p>
<p>The basic concept is to not draw directly onto the display but rather to first draw on an internal draw buffer. When a drawing (rendering) is ready that buffer is copied to the display.</p>
<p>The draw buffer can be smaller than a display's size. LVGL will simply render in &quot;tiles&quot; that fit into the given draw buffer.</p>
<p>This approach has two main advantages compared to directly drawing to the display:</p>
<ol class="arabic simple">
<li><p>It avoids flickering while the layers of the UI are drawn. For example, if LVGL drew directly onto the display, when drawing a <em>background + button + text</em>, each &quot;stage&quot; would be visible for a short time.</p></li>
<li><p>It's faster to modify a buffer in internal RAM and finally write one pixel only once than reading/writing the display directly on each pixel access.
(e.g. via a display controller with SPI interface).</p></li>
</ol>
<p>Note that this concept is different from &quot;traditional&quot; double buffering where there are two display sized frame buffers:
one holds the current image to show on the display, and rendering happens to the other (inactive) frame buffer, and they are swapped when the rendering is finished.
The main difference is that with LVGL you don't have to store two frame buffers (which usually requires external RAM) but only smaller draw buffer(s) that can easily fit into internal RAM.</p>
<section id="mechanism-of-screen-refreshing">
<h2>Mechanism of screen refreshing<a class="headerlink" href="#mechanism-of-screen-refreshing" title="此标题的永久链接"></a></h2>
<p>Be sure to get familiar with the <a class="reference internal" href="../porting/display.html"><span class="doc std std-doc">Buffering modes of LVGL</span></a> first.</p>
<p>LVGL refreshes the screen in the following steps:</p>
<ol class="arabic simple">
<li><p>Something happens in the UI which requires redrawing. For example, a button is pressed, a chart is changed, an animation happened, etc.</p></li>
<li><p>LVGL saves the changed object's old and new area into a buffer, called an <em>Invalid area buffer</em>. For optimization, in some cases, objects are not added to the buffer:</p>
<ul class="simple">
<li><p>Hidden objects are not added.</p></li>
<li><p>Objects completely out of their parent are not added.</p></li>
<li><p>Areas partially out of the parent are cropped to the parent's area.</p></li>
<li><p>Objects on other screens are not added.</p></li>
</ul>
</li>
<li><p>In every <code class="docutils literal notranslate"><span class="pre">LV_DISP_DEF_REFR_PERIOD</span></code> (set in <code class="docutils literal notranslate"><span class="pre">lv_conf.h</span></code>) the following happens:</p>
<ul class="simple">
<li><p>LVGL checks the invalid areas and joins those that are adjacent or intersecting.</p></li>
<li><p>Takes the first joined area, if it's smaller than the <em>draw buffer</em>, then simply renders the area's content into the <em>draw buffer</em>.
If the area doesn't fit into the buffer, draw as many lines as possible to the <em>draw buffer</em>.</p></li>
<li><p>When the area is rendered, call <code class="docutils literal notranslate"><span class="pre">flush_cb</span></code> from the display driver to refresh the display.</p></li>
<li><p>If the area was larger than the buffer, render the remaining parts too.</p></li>
<li><p>Repeat the same with remaining joined areas.</p></li>
</ul>
</li>
</ol>
<p>When an area is redrawn the library searches the top-most object which covers that area and starts drawing from that object.
For example, if a button's label has changed, the library will see that it's enough to draw the button under the text and it's not necessary to redraw the display under the rest of the button too.</p>
<p>The difference between buffering modes regarding the drawing mechanism is the following:</p>
<ol class="arabic simple">
<li><p><strong>One buffer</strong> - LVGL needs to wait for <code class="docutils literal notranslate"><span class="pre">lv_disp_flush_ready()</span></code> (called from <code class="docutils literal notranslate"><span class="pre">flush_cb</span></code>) before starting to redraw the next part.</p></li>
<li><p><strong>Two buffers</strong> -  LVGL can immediately draw to the second buffer when the first is sent to <code class="docutils literal notranslate"><span class="pre">flush_cb</span></code> because the flushing should be done by DMA (or similar hardware) in the background.</p></li>
<li><p><strong>Double buffering</strong> -  <code class="docutils literal notranslate"><span class="pre">flush_cb</span></code> should only swap the addresses of the frame buffers.</p></li>
</ol>
</section>
<section id="masking">
<h2>Masking<a class="headerlink" href="#masking" title="此标题的永久链接"></a></h2>
<p><em>Masking</em> is the basic concept of LVGL's draw engine.
To use LVGL it's not required to know about the mechanisms described here but you might find interesting to know how drawing works under hood.
Knowing about masking comes in handy if you want to customize drawing.</p>
<p>To learn about masking let's see the steps of drawing first.
LVGL performs the following steps to render any shape, image or text. It can be considered as a drawing pipeline.</p>
<ol class="arabic simple">
<li><p><strong>Prepare the draw descriptors</strong> Create a draw descriptor from an object's styles (e.g. <code class="docutils literal notranslate"><span class="pre">lv_draw_rect_dsc_t</span></code>).  This gives us the parameters for drawing, for example colors, widths, opacity, fonts, radius, etc.</p></li>
<li><p><strong>Call the draw function</strong> Call the draw function with the draw descriptor and some other parameters (e.g. <code class="docutils literal notranslate"><span class="pre">lv_draw_rect()</span></code>).  It will render the primitive shape to the current draw buffer.</p></li>
<li><p><strong>Create masks</strong> If the shape is very simple and doesn't require masks, go to #5. Otherwise, create the required masks in the draw function. (e.g. a rounded rectangle mask)</p></li>
<li><p><strong>Calculate all the added mask</strong> It composites opacity values into a <em>mask buffer</em> with the &quot;shape&quot; of the created masks.
E.g. in case of a &quot;line mask&quot; according to the parameters of the mask, keep one side of the buffer as it is (255 by default) and set the rest to 0 to indicate that this side should be removed.</p></li>
<li><p><strong>Blend a color or image</strong> During blending, masking (make some pixels transparent or opaque), blending modes (additive, subtractive, etc.) and color/image opacity are handled.</p></li>
</ol>
<p>LVGL has the following built-in mask types which can be calculated and applied real-time:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LV_DRAW_MASK_TYPE_LINE</span></code> Removes a side from a line (top, bottom, left or right). <code class="docutils literal notranslate"><span class="pre">lv_draw_line</span></code> uses four instances of it.
Essentially, every (skew) line is bounded with four line masks forming a rectangle.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LV_DRAW_MASK_TYPE_RADIUS</span></code> Removes the inner or outer corners of a rectangle with a radiused transition. It's also used to create circles by setting the radius to large value (<code class="docutils literal notranslate"><span class="pre">LV_RADIUS_CIRCLE</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LV_DRAW_MASK_TYPE_ANGLE</span></code> Removes a circular sector. It is used by <code class="docutils literal notranslate"><span class="pre">lv_draw_arc</span></code> to remove the &quot;empty&quot; sector.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LV_DRAW_MASK_TYPE_FADE</span></code> Create a vertical fade (change opacity)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LV_DRAW_MASK_TYPE_MAP</span></code> The mask is stored in a bitmap array and the necessary parts are applied</p></li>
</ul>
<p>Masks are used to create almost every basic primitive:</p>
<ul class="simple">
<li><p><strong>letters</strong> Create a mask from the letter and draw a rectangle with the letter's color using the mask.</p></li>
<li><p><strong>line</strong> Created from four &quot;line masks&quot; to mask out the left, right, top and bottom part of the line to get a perfectly perpendicular perimeter.</p></li>
<li><p><strong>rounded rectangle</strong> A mask is created real-time to add a radius to the corners.</p></li>
<li><p><strong>clip corner</strong> To clip overflowing content (usually children) on rounded corners, a rounded rectangle mask is also applied.</p></li>
<li><p><strong>rectangle border</strong> Same as a rounded rectangle but the inner part is masked out too.</p></li>
<li><p><strong>arc drawing</strong> A circular border is drawn but an arc mask is applied too.</p></li>
<li><p><strong>ARGB images</strong> The alpha channel is separated into a mask and the image is drawn as a normal RGB image.</p></li>
</ul>
<section id="using-masks">
<h3>Using masks<a class="headerlink" href="#using-masks" title="此标题的永久链接"></a></h3>
<p>Every mask type has a related parameter structure to describe the mask's data. The following parameter types exist:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lv_draw_mask_line_param_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lv_draw_mask_radius_param_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lv_draw_mask_angle_param_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lv_draw_mask_fade_param_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lv_draw_mask_map_param_t</span></code></p></li>
</ul>
<ol class="arabic simple">
<li><p>Initialize a mask parameter with <code class="docutils literal notranslate"><span class="pre">lv_draw_mask_&lt;type&gt;_init</span></code>. See <code class="docutils literal notranslate"><span class="pre">lv_draw_mask.h</span></code> for the whole API.</p></li>
<li><p>Add the mask parameter to the draw engine with <code class="docutils literal notranslate"><span class="pre">int16_t</span> <span class="pre">mask_id</span> <span class="pre">=</span> <span class="pre">lv_draw_mask_add(&amp;param,</span> <span class="pre">ptr)</span></code>. <code class="docutils literal notranslate"><span class="pre">ptr</span></code> can be any pointer to identify the mask, (<code class="docutils literal notranslate"><span class="pre">NULL</span></code> if unused).</p></li>
<li><p>Call the draw functions</p></li>
<li><p>Remove the mask from the draw engine with <code class="docutils literal notranslate"><span class="pre">lv_draw_mask_remove_id(mask_id)</span></code> or <code class="docutils literal notranslate"><span class="pre">lv_draw_mask_remove_custom(ptr)</span></code>.</p></li>
<li><p>Free the parameter with <code class="docutils literal notranslate"><span class="pre">lv_draw_mask_free_param(&amp;param)</span></code>.</p></li>
</ol>
<p>A parameter can be added and removed any number of times, but it needs to be freed when not required anymore.</p>
<p><code class="docutils literal notranslate"><span class="pre">lv_draw_mask_add</span></code> saves only the pointer of the mask so the parameter needs to be valid while in use.</p>
</section>
</section>
<section id="hook-drawing">
<h2>Hook drawing<a class="headerlink" href="#hook-drawing" title="此标题的永久链接"></a></h2>
<p>Although widgets can be easily customized by styles there might be cases when something more custom is required.
To ensure a great level of flexibility LVGL sends a lot of events during drawing with parameters that tell what LVGL is about to draw.
Some fields of these parameters can be modified to draw something else or any custom drawing operations can be added manually.</p>
<p>A good use case for this is the <a class="reference internal" href="../widgets/core/btnmatrix.html"><span class="doc std std-doc">Button matrix</span></a> widget. By default, its buttons can be styled in different states, but you can't style the buttons one by one.
However, an event is sent for every button and you can, for example, tell LVGL to use different colors on a specific button or to manually draw an image on some buttons.</p>
<p>Each of these events is described in detail below.</p>
<section id="main-drawing">
<h3>Main drawing<a class="headerlink" href="#main-drawing" title="此标题的永久链接"></a></h3>
<p>These events are related to the actual drawing of an object. E.g. the drawing of buttons, texts, etc. happens here.</p>
<p><code class="docutils literal notranslate"><span class="pre">lv_event_get_clip_area(event)</span></code> can be used to get the current clip area. The clip area is required in draw functions to make them draw only on a limited area.</p>
<section id="lv-event-draw-main-begin">
<h4>LV_EVENT_DRAW_MAIN_BEGIN<a class="headerlink" href="#lv-event-draw-main-begin" title="此标题的永久链接"></a></h4>
<p>Sent before starting to draw an object. This is a good place to add masks manually. E.g. add a line mask that &quot;removes&quot; the right side of an object.</p>
</section>
<section id="lv-event-draw-main">
<h4>LV_EVENT_DRAW_MAIN<a class="headerlink" href="#lv-event-draw-main" title="此标题的永久链接"></a></h4>
<p>The actual drawing of an object happens in this event. E.g. a rectangle for a button is drawn here. First, the widgets' internal events are called to perform drawing and after that you can draw anything on top of them.
For example you can add a custom text or an image.</p>
</section>
<section id="lv-event-draw-main-end">
<h4>LV_EVENT_DRAW_MAIN_END<a class="headerlink" href="#lv-event-draw-main-end" title="此标题的永久链接"></a></h4>
<p>Called when the main drawing is finished. You can draw anything here as well and it's also a good place to remove any masks created in <code class="docutils literal notranslate"><span class="pre">LV_EVENT_DRAW_MAIN_BEGIN</span></code>.</p>
</section>
</section>
<section id="post-drawing">
<h3>Post drawing<a class="headerlink" href="#post-drawing" title="此标题的永久链接"></a></h3>
<p>Post drawing events are called when all the children of an object are drawn. For example LVGL use the post drawing phase to draw scrollbars because they should be above all of the children.</p>
<p><code class="docutils literal notranslate"><span class="pre">lv_event_get_clip_area(event)</span></code> can be used to get the current clip area.</p>
<section id="lv-event-draw-post-begin">
<h4>LV_EVENT_DRAW_POST_BEGIN<a class="headerlink" href="#lv-event-draw-post-begin" title="此标题的永久链接"></a></h4>
<p>Sent before starting the post draw phase. Masks can be added here too to mask out the post drawn content.</p>
</section>
<section id="lv-event-draw-post">
<h4>LV_EVENT_DRAW_POST<a class="headerlink" href="#lv-event-draw-post" title="此标题的永久链接"></a></h4>
<p>The actual drawing should happen here.</p>
</section>
<section id="lv-event-draw-post-end">
<h4>LV_EVENT_DRAW_POST_END<a class="headerlink" href="#lv-event-draw-post-end" title="此标题的永久链接"></a></h4>
<p>Called when post drawing has finished. If masks were not removed in <code class="docutils literal notranslate"><span class="pre">LV_EVENT_DRAW_MAIN_END</span></code> they should be removed here.</p>
</section>
</section>
<section id="part-drawing">
<h3>Part drawing<a class="headerlink" href="#part-drawing" title="此标题的永久链接"></a></h3>
<p>When LVGL draws a part of an object (e.g. a slider's indicator, a table's cell or a button matrix's button) it sends events before and after drawing that part with some context of the drawing.
This allows changing the parts on a very low level with masks, extra drawing, or changing the parameters that LVGL is planning to use for drawing.</p>
<p>In these events an <code class="docutils literal notranslate"><span class="pre">lv_obj_draw_part_t</span></code> structure is used to describe the context of the drawing. Not all fields are set for every part and widget.
To see which fields are set for a widget refer to the widget's documentation.</p>
<p><code class="docutils literal notranslate"><span class="pre">lv_obj_draw_part_t</span></code> has the following fields:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Always set</span>
<span class="k">const</span><span class="w"> </span><span class="n">lv_area_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">clip_area</span><span class="p">;</span><span class="w">        </span><span class="c1">// The current clip area, required if you need to draw something in the event</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">part</span><span class="p">;</span><span class="w">                      </span><span class="c1">// The current part for which the event is sent</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">                        </span><span class="c1">// The index of the part. E.g. a button&#39;s index on button matrix or table cell index.</span>

<span class="c1">// Draw desciptors, set only if related</span>
<span class="n">lv_draw_rect_dsc_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rect_dsc</span><span class="p">;</span><span class="w">      </span><span class="c1">// A draw descriptor that can be modified to changed what LVGL will draw. Set only for rectangle-like parts</span>
<span class="n">lv_draw_label_dsc_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">label_dsc</span><span class="p">;</span><span class="w">    </span><span class="c1">// A draw descriptor that can be modified to changed what LVGL will draw. Set only for text-like parts</span>
<span class="n">lv_draw_line_dsc_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">line_dsc</span><span class="p">;</span><span class="w">      </span><span class="c1">// A draw descriptor that can be modified to changed what LVGL will draw. Set only for line-like parts</span>
<span class="n">lv_draw_img_dsc_t</span><span class="w"> </span><span class="o">*</span><span class="w">  </span><span class="n">img_dsc</span><span class="p">;</span><span class="w">       </span><span class="c1">// A draw descriptor that can be modified to changed what LVGL will draw. Set only for image-like parts</span>
<span class="n">lv_draw_arc_dsc_t</span><span class="w"> </span><span class="o">*</span><span class="w">  </span><span class="n">arc_dsc</span><span class="p">;</span><span class="w">       </span><span class="c1">// A draw descriptor that can be modified to changed what LVGL will draw. Set only for arc-like parts</span>

<span class="c1">// Other parameters </span>
<span class="n">lv_area_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">draw_area</span><span class="p">;</span><span class="w">              </span><span class="c1">// The area of the part being drawn</span>
<span class="k">const</span><span class="w"> </span><span class="n">lv_point_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span><span class="w">              </span><span class="c1">// A point calculated during drawing. E.g. a point of a chart or the center of an arc.</span>
<span class="k">const</span><span class="w"> </span><span class="n">lv_point_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">              </span><span class="c1">// A point calculated during drawing. E.g. a point of a chart.</span>
<span class="kt">char</span><span class="w"> </span><span class="n">text</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w">                      </span><span class="c1">// A text calculated during drawing. Can be modified. E.g. tick labels on a chart axis.</span>
<span class="n">lv_coord_t</span><span class="w"> </span><span class="n">radius</span><span class="p">;</span><span class="w">                  </span><span class="c1">// E.g. the radius of an arc (not the corner radius).</span>
<span class="kt">int32_t</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">                      </span><span class="c1">// A value calculated during drawing. E.g. Chart&#39;s tick line value.</span>
<span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sub_part_ptr</span><span class="p">;</span><span class="w">          </span><span class="c1">// A pointer the identifies something in the part. E.g. chart series. </span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">lv_event_get_draw_part_dsc(event)</span></code> can be used to get a pointer to <code class="docutils literal notranslate"><span class="pre">lv_obj_draw_part_t</span></code>.</p>
<section id="lv-event-draw-part-begin">
<h4>LV_EVENT_DRAW_PART_BEGIN<a class="headerlink" href="#lv-event-draw-part-begin" title="此标题的永久链接"></a></h4>
<p>Start the drawing of a part. This is a good place to modify the draw descriptors (e.g. <code class="docutils literal notranslate"><span class="pre">rect_dsc</span></code>), or add masks.</p>
</section>
<section id="lv-event-draw-part-end">
<h4>LV_EVENT_DRAW_PART_END<a class="headerlink" href="#lv-event-draw-part-end" title="此标题的永久链接"></a></h4>
<p>Finish the drawing of a part. This is a good place to draw extra content on the part or remove masks added in <code class="docutils literal notranslate"><span class="pre">LV_EVENT_DRAW_PART_BEGIN</span></code>.</p>
</section>
</section>
<section id="others">
<h3>Others<a class="headerlink" href="#others" title="此标题的永久链接"></a></h3>
<section id="lv-event-cover-check">
<h4>LV_EVENT_COVER_CHECK<a class="headerlink" href="#lv-event-cover-check" title="此标题的永久链接"></a></h4>
<p>This event is used to check whether an object fully covers an area or not.</p>
<p><code class="docutils literal notranslate"><span class="pre">lv_event_get_cover_area(event)</span></code> returns a pointer to an area to check and <code class="docutils literal notranslate"><span class="pre">lv_event_set_cover_res(event,</span> <span class="pre">res)</span></code> can be used to set one of these results:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LV_COVER_RES_COVER</span></code> the area is fully covered by the object</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LV_COVER_RES_NOT_COVER</span></code> the area is not covered by the object</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LV_COVER_RES_MASKED</span></code> there is a mask on the object, so it does not fully cover the area</p></li>
</ul>
<p>Here are some reasons why an object would be unable to fully cover an area:</p>
<ul class="simple">
<li><p>It's simply not fully in area</p></li>
<li><p>It has a radius</p></li>
<li><p>It doesn't have 100% background opacity</p></li>
<li><p>It's an ARGB or chroma keyed image</p></li>
<li><p>It does not have normal blending mode. In this case LVGL needs to know the colors under the object to apply blending properly</p></li>
<li><p>It's a text, etc</p></li>
</ul>
<p>In short if for any reason the area below an object is visible than the object doesn't cover that area.</p>
<p>Before sending this event LVGL checks if at least the widget's coordinates fully cover the area or not. If not the event is not called.</p>
<p>You need to check only the drawing you have added. The existing properties known by a widget are handled in its internal events.
E.g. if a widget has &gt; 0 radius it might not cover an area, but you need to handle <code class="docutils literal notranslate"><span class="pre">radius</span></code> only if you will modify it and the widget won't know about it.</p>
</section>
<section id="lv-event-refr-ext-draw-size">
<h4>LV_EVENT_REFR_EXT_DRAW_SIZE<a class="headerlink" href="#lv-event-refr-ext-draw-size" title="此标题的永久链接"></a></h4>
<p>If you need to draw outside a widget, LVGL needs to know about it to provide extra space for drawing.
Let's say you create an event which writes the current value of a slider above its knob. In this case LVGL needs to know that the slider's draw area should be larger with the size required for the text.</p>
<p>You can simply set the required draw area with <code class="docutils literal notranslate"><span class="pre">lv_event_set_ext_draw_size(e,</span> <span class="pre">size)</span></code>.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021, LVGL Kft.
      <span class="lastupdated">最后更新于 2025 年 09 月 02 日.
      </span></p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

<style>
  .wy-side-nav-search > div[role="search"] {
    color: black;
  }
</style>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

<script type="text/javascript">
function add_version_selector()
{
    return fetch("https://raw.githubusercontent.com/lvgl/docs_compiled/gh-pages/versionlist.txt")
        .then(res => res.text())
        .then(text => {
            const versions = text.split("\n").filter(version => version.trim().length > 0);
            let p = document.getElementById("rtd-search-form").parentElement;
            p.innerHTML = `
            <select name="versions" id="versions" onchange="ver_sel()" style="border-radius:5px; margin-bottom:15px">
            ${versions.map(version => {
                let versionName = "";  
                if(version == "master") versionName = "master (latest)";
                else versionName = "v" + ((version.indexOf(".") != -1) ? version : (version + " (latest minor)"));
                return `<option value="${version}">${versionName}</option>`;
            })}
            </select>` + p.innerHTML;
        });
}

function ver_sel()
{
  var x = document.getElementById("versions").value;
  window.location.href = window.location.protocol + "//" + window.location.host + "/" + x + "/";
}

document.addEventListener('DOMContentLoaded', (event) => {
    add_version_selector().then(() => {
        var value = window.location.pathname.split('/')[1];
        document.getElementById("versions").value = value;
    });
    
})
document.addEventListener('DOMContentLoaded', (event) => {
    function onIntersection(entries) {
        entries.forEach(entry => {
            let currentlyLoaded = entry.target.getAttribute("data-is-loaded") == "true";
            let shouldBeLoaded = entry.intersectionRatio > 0;
            if(currentlyLoaded != shouldBeLoaded) {
                entry.target.setAttribute("data-is-loaded", shouldBeLoaded);
                if(shouldBeLoaded) {
                    let iframe = document.createElement("iframe");
                    iframe.src = entry.target.getAttribute("data-real-src");
                    entry.target.appendChild(iframe);
                } else {
                    let iframe = entry.target.querySelector("iframe");
                    iframe.parentNode.removeChild(iframe);
                }
            }
        });
    }
    const config = {
        rootMargin: '600px 0px',
        threshold: 0.01
    };
    let observer = new IntersectionObserver(onIntersection, config);
    document.querySelectorAll(".lv-example").forEach(iframe => {
        observer.observe(iframe);
    });
});
</script>


</body>
</html>